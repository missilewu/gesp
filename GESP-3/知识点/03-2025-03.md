# GESP三级C++2025年3月考试考点、易错点及相关知识点总结

## 一、考察的知识点（按模块分类）
### （一）编码与数制转换（单选题1-9题，核心模块）
1. **Base64编码规则和计算**：  
   - 核心逻辑：每3字节输入编码成4字节的输出，不足3字节时用`=`补位，向上补位到3的倍数；  
   - 长度计算：输入长度`L`，编码后长度=`ceil(L/3)×4`（向上取整后乘4）。
1. **UTF-8编码合法性判断**：  
   - 1字节：首字节以`0`开头（`0xxxxxxx`）；  
   - 2字节：首字节`110xxxxx` + 一个`10xxxxxx` 后续字节；  
   - 3字节：首字节`1110xxxx` + 两个`10xxxxxx`后续字节；  
   - 4字节：首字节`11110xxx` + 三个`10xxxxxx`后续字节；  
   - 非法情况：首字节不符合对应长度标识、后续字节不以`10`开头、使用长字节表示可以较少字节表示的编码。
1. **原码/补码特性**：  
   - 8位原码：符号位`0`为正、`1`为负，数值位直接表示绝对值（如-5的原码为`10000101`）；  
   - 8位补码：范围`-128~127`，核心作用是**简化整数加减法运算**（将减法转化为加法，符号位参与运算）。
4. **进制转换（流操作符）**：  
   - `oct`：十进制→八进制输出（如`cout << oct << 25`输出`31`）；  
   - `hex`：十进制→十六进制输出（如`cout << hex << 255`输出`ff`）；  
   - 二进制直接声明：`0bxxxx`（如`0b1101`表示十进制13）。

### （二）位运算（单选题10题+编程题1）
1. **按位运算规则**：  
   - 按位异或（`^`）：对应位不同为1，相同为0（如`0b1101 ^ 0b1011 = 0b0110`）；  
   - 按位与（`&`）：对应位均为1才为1（可用于判断奇偶：`x&1`为1则x是奇数）。
2. **位运算公式应用**：  
   - 核心公式：`(x & y) + (x | y) = x + y`（编程题1关键，直接推导`y=2025-x`，无需枚举）。

### （三）数组操作（单选题11-12题）
1. **枚举法查找最大值索引**：  
   - 逻辑：初始化`maxIndex=0`，遍历数组时若`arr[i] > arr[maxIndex]`，则更新`maxIndex=i`。
2. **双指针法分离奇偶元素**：  
   - 左指针`left`从左找偶数（`arr[left]%2==0`），右指针`right`从右找奇数（`arr[right]%2!=0`）；  
   - 找到后交换两指针位置元素，直到`left>=right`。

### （四）string类操作（单选题13-14题）
1. **核心成员函数**：  
   - `replace(pos, len, str)`：从下标`pos`开始，替换`len`个字符为`str`（如`"HelloWorld".replace(5,5,"C++")`得到`"HelloC++"`）；  
   - `substr(pos, len)`：从下标`pos`开始，截取`len`个字符（如`"HelloWorld".substr(5,5)`得到`"World"`）；  
   - `insert(pos, str)`：在下标`pos`处（指向的字符前面）插入`str`（如`"HelloC++".insert(5,"World")`得到`"HelloWorldC++"`）。

### （五）条件判断与逻辑运算（单选题15题+判断题）
1. **逻辑运算符区别**：  
   - `&&`：逻辑与（短路求值，左为假则右不执行）；  
   - `&`：按位与（非逻辑判断，左右均执行，不可替代`&&`）。
2. **常见条件判断**：  
   - 美丽数字：`a%9==0 && a%8!=0`（9的倍数且非8的倍数）；  
   - 闰年判断：`(n%4==0 && n%100!=0) || (n%400==0)`；  
   - 被3和5同时整除：`n%15==0`（3和5互质，最小公倍数15）。

### （六）编程算法（编程题1-2题）
1. **枚举法（编程题1）**：  
   - 题目本质：利用位运算公式简化为`y=2025-x`，直接输出`2025-x`（因`x<2025`，`y`为正整数，必存在，无需输出-1）。
2. **词频统计（编程题2，贪心+哈希）**：  
   - 大小写忽略：用`transform(s.begin(), s.end(), s.begin(), ::tolower)`将单词转为小写；  
   - 统计工具：`map<string, int>`存储单词出现次数（键为小写单词，值为次数）；  
   - 核心逻辑：遍历`map`找到次数最大值对应的单词。

## 二、易错点
### （一）编码与数制类（高频易错）
1. **Base64编码长度计算错误**：  
   - 错误原因：未掌握补位规则（如10字节输入：`3×3=9`字节→12字节，剩余1字节需补2个`=`后变成3的倍数个字节（3字节对齐），总长度`12+4=16`）；  
   - 易错选：误算为12或14字节，忽略“不足3字节时需要补齐”。
1. **UTF-8合法序列判断失误**：  
   - 错误案例：误选`0xC0 0x80`（`0xC0`是2字节首字节，但对应U+0000，规范要求用1字节`0x00`表示，属于非法）；  
   - 关键：首字节需匹配后续字节数量，且后续字节必须以`10`开头。
3. **原码与补码混淆**：  
   - 错误：将-5的补码（`11111011`）当作原码，误选第3题C选项；  
   - 纠正：原码符号位不变，数值位为绝对值的二进制（-5原码=1+0000101=10000101）。
4. **补码作用误解**：  
   - 错误：认为补码的主要作用是“增加表示范围”（第5题误选C）；  
   - 纠正：增加范围是副作用，核心作用是简化加减法（无需单独处理符号位）。

### （二）位运算与数组类
1. **按位运算类型混淆**：  
   - 错误：将`a^b`当作“整体异或”或“同或”（第10题误选A或B）；  
   - 纠正：C++中`^`仅表示“按位异或”，无“整体异或”概念。
2. **双指针法条件写反**：  
   - 错误：分离奇偶时，`right`指针判断条件写为`arr[right]%2==0`（第12题误选A）；  
   - 纠正：`right`需找奇数（保留在右侧），条件应为`arr[right]%2==0`时`right--`（直到找到奇数）。
3. **最大值索引比较逻辑错误**：  
   - 错误：在`if`条件中加1或减1（如`arr[i]+1>arr[maxIndex]`，第11题误选C）；  
   - 纠正：直接比较元素大小，无需额外加减。

### （三）string类与逻辑运算类
1. **string函数参数混淆**：  
   - 错误：`replace`的`pos`或`len`算错（如第13题误选A，用`pos=0`替换，导致结果为`"C++World"`）；  
   - 关键：`HelloWorld`中`World`从下标5开始，长度为5，需替换`pos=5, len=5`。
2. **逻辑运算符`&&`与`&`混用**：  
   - 错误：第15题用`a%9==0 & a%8!=0`（误选D）；  
   - 纠正：逻辑判断需用`&&`（短路求值，效率高），`&`是按位与，可能导致非预期结果。
3. **substr长度参数错误**：  
   - 错误：第14题插入`World`后，认为是从 w开始后面的4个字节(实际上是w的前面)`substr(5,4)`（误选A）；  
   - 纠正：`World`长度为5，从W开始，需截取`len=5`，即`substr(5,5)`。

### （四）编程题类
1. **编程题1枚举范围冗余**：  
   - 错误：按参考程序枚举`i=1~2025`，未利用`(x&y)+(x|y)=x+y`公式；  
   - 优化：直接计算`y=2025-x`，无需循环，避免超时（虽数据范围小，但体现算法思维）。
2. **词频统计忘记大小写转换**：  
   - 错误：未用`transform`转换，导致`Apple`和`apple`被视为不同单词；  
   - 后果：统计次数错误，无法找到正确的最多单词。

## 三、相关的知识点（延伸与拓展）
### （一）编码与数制延伸
1. **Base64编码细节**：  
   - 编码表：64个字符`（A-Z、a-z、0-9、+、/）`，每个字符对应6位二进制；  
   - 示例：输入`"AB"`（2字节）→编码为`"QUI="`（4字节，补1个`=`）。
2. **UTF-8更多非法案例**：  
   - 首字节`0x80`（`10xxxxxx`）：无对应首字节标识，非法；  
   - 首字节`0xF8`（`11111000`）：超过4字节编码范围（UTF-8最多4字节），非法。
1. **进制转换的其他方法**：  
   - 十进制→二进制：用`x%2`取余、`x/2`迭代（判断题7程序逻辑）；  
   - 十六进制→十进制：`0x1A`（`1×16+10=26`）。

### （二）位运算延伸
1. **更多实用位运算公式**：  
   - `x ^ x = 0`（异或自身为0）；  
   - `x ^ 0 = x`（异或0不变）；  
   - `x & (x-1)`：清除最低位的1（统计二进制1的个数优化）。
2. **位运算应用场景**：  
   - 交换变量（无临时变量）：`a=a^b; b=a^b; a=a^b;`；  
   - 判断幂次：`x & (x-1) == 0`（x是2的幂次，如8→1000，8-1=0111，与运算为0）。

### （三）数组与string延伸
1. **双指针法其他应用**：  
   - 数组排序后去重；  
   - 两数之和（有序数组）。
2. **string类其他常用函数**：  
   - `find(str)`：从左查找`str`，返回首次出现下标（未找到返回`string::npos`）；  
   - `erase(pos, len)`：从下标`pos`删除`len`个字符；  
   - `tolower`与`toupper`：单独字符大小写转换（需包含`<cctype>`）。

### （四）编程算法延伸（部分超纲）
1. **map的遍历方式**：  
   - 范围for循环（C++11及以上）：`for (auto [s, cnt] : cnt_map) { ... }`，更简洁；  
   - 迭代器遍历：`map<string, int>::iterator it = cnt_map.begin();`。
2. **词频统计的其他实现**：  
   - 用`unordered_map`（哈希表，查询效率`O(1)`，比`map`的`O(logn)`更高）；  
   - 手动实现大小写转换（遍历字符串，`s[i] = tolower(s[i])`）。
3. **枚举法优化技巧**：  
   - 明确枚举边界（如编程题1中`y=2025-x`，边界`y>0`，因`x<2025`，`y`天然为正）；  
   - 避免无效循环（如无需从1遍历到2025，直接计算结果）。